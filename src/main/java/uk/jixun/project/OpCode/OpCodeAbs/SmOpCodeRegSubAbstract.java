package uk.jixun.project.OpCode.OpCodeAbs;



// !!!                               !!!
// !!!             STOP              !!!
// !!!                               !!!
//     DO NOT EDIT THIS FILE BY HAND    


// This file was generated using an automated script.
// See 'scripts' directory for more information



import uk.jixun.project.OpCode.AbstractBasicOpCode;
import uk.jixun.project.OpCode.SmOpCodeEnum;
import uk.jixun.project.Register.SmRegister;

public abstract class SmOpCodeRegSubAbstract extends AbstractBasicOpCode {
  @Override
  public SmOpCodeEnum getOpCode() {
    return SmOpCodeEnum.REG_SUB;
  }

  @Override
  public String toAssembly() {
    
    if (getRegisterVariant() == SmRegister.SP) {
      return "SP-";
    }

    if (getRegisterVariant() == SmRegister.RP) {
      return "RP-";
    }

    if (getRegisterVariant() == SmRegister.YP) {
      return "YP-";
    }

    if (getRegisterVariant() == SmRegister.XP) {
      return "XP-";
    }

    if (getRegisterVariant() == SmRegister.FP) {
      return "FP-";
    }

    throw new RuntimeException("Unsupported register variant for this opcode.");
  }

  @Override
  public void setVariant(int variant) {
    throw new RuntimeException("Variant does not apply for this opcode.");
  }

  @Override
  public void setRegisterVariant(SmRegister regVariant) {
    if (regVariant != SmRegister.SP && regVariant != SmRegister.RP && regVariant != SmRegister.YP && regVariant != SmRegister.XP && regVariant != SmRegister.FP) {
      this.regVariant = regVariant;
    }

    throw new RuntimeException("Register variant " + regVariant.toString()
      + " is not allowed for opcode REG_SUB");
  }
}